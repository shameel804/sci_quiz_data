{
    "id": "learn_data",
    "topicId": "data",
    "topicTitle": "Data Structures",
    "description": "Explore arrays, linked lists, trees, graphs, and other fundamental structures",
    "baseKP": 75,
    "slides": [
        {
            "id": "datastruct_1",
            "type": "content",
            "title": "Welcome to Data Structures",
            "content": "# Introduction to Data Structures\n\nWelcome to **Data Structures** - organizing data efficiently!\n\n## What You Will Learn:\n- **Linear Structures** - Arrays, lists, stacks, queues\n- **Trees** - Hierarchical data\n- **Graphs** - Networks\n- **Hash Tables** - Fast lookup\n\n> **Fun Fact:** Choosing the right data structure can make your code 1000x faster!"
        },
        {
            "id": "datastruct_2",
            "type": "content",
            "title": "Arrays and Linked Lists",
            "content": "# Arrays and Linked Lists\n\n## Arrays:\n- Contiguous memory\n- Fixed size (usually)\n- Random access O(1)\n- Insert/delete O(n)\n\n## Linked Lists:\n- Nodes with pointers\n- Dynamic size\n- Access O(n)\n- Insert/delete O(1) if position known\n\n## Comparison:\n\n| Operation | Array | Linked List |\n|-----------|-------|-------------|\n| Access | O(1) | O(n) |\n| Search | O(n) | O(n) |\n| Insert at front | O(n) | O(1) |\n| Insert at end | O(1)* | O(n) or O(1) |\n| Delete | O(n) | O(1) |\n\n*If space available\n\n## Types of Linked Lists:\n- Singly linked\n- Doubly linked\n- Circular"
        },
        {
            "id": "datastruct_3",
            "type": "content",
            "title": "Stacks and Queues",
            "content": "# Stacks and Queues\n\n## Stack:\n- LIFO (Last In, First Out)\n- Operations: push, pop, peek\n- All O(1)\n\n**Uses:**\n- Function call stack\n- Undo operations\n- Expression evaluation\n- Backtracking\n\n## Queue:\n- FIFO (First In, First Out)\n- Operations: enqueue, dequeue, front\n- All O(1)\n\n**Uses:**\n- Task scheduling\n- Print queue\n- BFS traversal\n- Buffering\n\n## Deque:\n- Double-ended queue\n- Insert/remove at both ends\n\n## Priority Queue:\n- Elements have priority\n- Highest priority dequeued first\n- Usually implemented with heap"
        },
        {
            "id": "datastruct_quiz_1",
            "type": "quiz",
            "title": "Data Structures Quiz",
            "content": "Test your knowledge!",
            "quizQuestion": "A stack follows which principle?",
            "quizOptions": [
                "FIFO",
                "LIFO",
                "Random",
                "Sorted"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "datastruct_4",
            "type": "content",
            "title": "Trees",
            "content": "# Trees\n\n## Basic Concepts:\n- Root: Top node\n- Parent/Child relationships\n- Leaf: Node with no children\n- Height: Longest path to leaf\n\n## Binary Tree:\n- Each node has at most 2 children\n- Left and right child\n\n## Binary Search Tree (BST):\n- Left subtree < node < right subtree\n- Search, insert, delete: O(log n) average\n- Can degrade to O(n) if unbalanced\n\n## Balanced Trees:\n- AVL: Height-balanced\n- Red-Black: Color-based balancing\n- Guarantee O(log n) operations\n\n## Traversals:\n- In-order: left, root, right (sorted for BST)\n- Pre-order: root, left, right\n- Post-order: left, right, root\n- Level-order: BFS"
        },
        {
            "id": "datastruct_5",
            "type": "content",
            "title": "Graphs",
            "content": "# Graphs\n\n## Definition:\n- Vertices (nodes) and edges (connections)\n- Directed or undirected\n- Weighted or unweighted\n\n## Representations:\n\n**Adjacency Matrix:**\n- 2D array\n- Space: O(V^2)\n- Edge lookup: O(1)\n\n**Adjacency List:**\n- Array of lists\n- Space: O(V + E)\n- Edge lookup: O(degree)\n\n## Graph Traversals:\n\n**Depth-First Search (DFS):**\n- Use stack (or recursion)\n- Go deep before wide\n\n**Breadth-First Search (BFS):**\n- Use queue\n- Go wide before deep\n- Finds shortest path (unweighted)\n\n## Classic Algorithms:\n- Dijkstra's: Shortest path\n- Topological sort: Dependencies\n- Minimum spanning tree"
        },
        {
            "id": "datastruct_6",
            "type": "content",
            "title": "Hash Tables",
            "content": "# Hash Tables\n\n## Concept:\n- Key-value pairs\n- Hash function maps key to index\n- O(1) average operations\n\n## Hash Function:\n- Maps key to integer\n- Should distribute evenly\n- Example: hashCode() % size\n\n## Collision Handling:\n\n**Chaining:**\n- Each slot has a list\n- Collisions stored in list\n\n**Open Addressing:**\n- Find next available slot\n- Linear, quadratic, double hashing\n\n## Performance:\n\n| Operation | Average | Worst |\n|-----------|---------|-------|\n| Insert | O(1) | O(n) |\n| Search | O(1) | O(n) |\n| Delete | O(1) | O(n) |\n\n## Load Factor:\n- Elements / slots\n- Resize when too high (~0.75)"
        },
        {
            "id": "datastruct_quiz_2",
            "type": "quiz",
            "title": "Trees Quiz",
            "content": "Test your knowledge!",
            "quizQuestion": "In a BST, all values in the left subtree are:",
            "quizOptions": [
                "Greater than the root",
                "Less than the root",
                "Equal to the root",
                "Random"
            ],
            "correctOptionIndex": 1
        },
        {
            "id": "datastruct_7",
            "type": "content",
            "title": "Summary",
            "content": "# Data Structures Summary\n\n## Linear Structures:\n| Structure | Best Use |\n|-----------|----------|\n| Array | Random access |\n| Linked List | Frequent insertion |\n| Stack | LIFO operations |\n| Queue | FIFO operations |\n\n## Hierarchical:\n- Binary Search Tree: Sorted data\n- Balanced trees: Guaranteed O(log n)\n- Heap: Priority queue\n\n## Graphs:\n- Adjacency list vs matrix\n- DFS (stack) vs BFS (queue)\n\n## Hash Table:\n- O(1) average lookup\n- Collision handling important\n\n> **Congratulations!** You've completed Data Structures!"
        }
    ]
}