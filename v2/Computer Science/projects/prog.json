[
    {
        "title": "Variables and Types üì¶",
        "ques": "Explain the difference between **static typing** and **dynamic typing** with examples.",
        "answer": {
            "type": "text",
            "content": "**Static Typing:**\nType checked at compile time\n```java\nint x = 5;      // x must be int\nString s = 10;  // Error at compile time!\n```\n*Languages:* Java, C, C++, TypeScript\n\n**Dynamic Typing:**\nType checked at runtime\n```python\nx = 5       # x is int\nx = \"hello\" # x is now string - OK!\n```\n*Languages:* Python, JavaScript, Ruby\n\n**Trade-offs:**\n- Static: Catches errors early, better tooling\n- Dynamic: More flexible, faster development"
        },
        "explanation": "Strong vs weak typing is different: strong prevents implicit conversions, weak allows them."
    },
    {
        "title": "OOP Principles üèóÔ∏è",
        "ques": "Explain the **4 pillars** of Object-Oriented Programming.",
        "answer": {
            "type": "text",
            "content": "**Four Pillars of OOP:**\n\n| Pillar | Definition | Example |\n|--------|------------|--------|\n| **Encapsulation** | Bundle data + methods, hide internals | Private variables, getters/setters |\n| **Abstraction** | Hide complexity, show essentials | Abstract classes, interfaces |\n| **Inheritance** | Classes inherit from parent classes | Dog extends Animal |\n| **Polymorphism** | Same interface, different behaviors | Method overriding |"
        },
        "explanation": "OOP models real-world entities. Promotes code reuse, maintainability, and modular design."
    },
    {
        "title": "Functions and Scope üî≤",
        "ques": "Explain **variable scope** and the difference between local and global variables.",
        "answer": {
            "type": "text",
            "content": "**Scope:** Where a variable is accessible\n\n**Global Variables:**\n- Defined outside functions\n- Accessible everywhere\n- Persist for program lifetime\n\n**Local Variables:**\n- Defined inside functions\n- Only accessible within that function\n- Created/destroyed with function call\n\n```python\nglobal_var = 10  # Global\n\ndef foo():\n    local_var = 5  # Local\n    print(global_var)  # OK\n    \nprint(local_var)  # Error!\n```"
        },
        "explanation": "Avoid global variables when possible‚Äîthey make code harder to debug and test."
    },
    {
        "title": "Control Flow üîÄ",
        "ques": "Compare **if-else, switch, and loops** (for, while, do-while).",
        "answer": {
            "type": "text",
            "content": "**Conditional Statements:**\n```\nif (condition):\n    // code\nelif (condition2):\n    // code\nelse:\n    // code\n```\n\n**Switch (multiple cases):**\n```\nswitch(value):\n    case 1: // code; break\n    case 2: // code; break\n    default: // code\n```\n\n**Loops:**\n| Loop | Use When |\n|------|----------|\n| **for** | Known number of iterations |\n| **while** | Unknown iterations, check first |\n| **do-while** | Unknown iterations, run at least once |"
        },
        "explanation": "break exits loop, continue skips to next iteration. Avoid infinite loops!"
    },
    {
        "title": "Debugging üêõ",
        "ques": "What are common **debugging techniques** and types of errors?",
        "answer": {
            "type": "text",
            "content": "**Error Types:**\n| Type | When | Example |\n|------|------|--------|\n| **Syntax** | Compile time | Missing semicolon |\n| **Runtime** | During execution | Division by zero |\n| **Logic** | Wrong output | Off-by-one error |\n\n**Debugging Techniques:**\n1. **Print statements** - Check variable values\n2. **Debugger** - Step through code\n3. **Rubber duck** - Explain code aloud\n4. **Binary search** - Comment out code sections\n5. **Stack trace** - Follow error path"
        },
        "explanation": "Logic errors are hardest‚Äîprogram runs but gives wrong results. Tests help catch them."
    },
    {
        "title": "Error Handling ‚ö†Ô∏è",
        "ques": "Explain **try-catch-finally** exception handling.",
        "answer": {
            "type": "code",
            "content": "try:\n    # Code that might throw exception\n    result = 10 / 0\n    \nexcept ZeroDivisionError:\n    # Handle specific error\n    print(\"Cannot divide by zero!\")\n    \nexcept Exception as e:\n    # Handle any other error\n    print(f\"Error: {e}\")\n    \nfinally:\n    # Always executes (cleanup)\n    print(\"Cleanup complete\")",
            "lang": "python"
        },
        "explanation": "Exceptions allow graceful error recovery. finally runs even if an exception is raised‚Äîgood for closing files/connections."
    },
    {
        "title": "Recursion vs Iteration üîÅ",
        "ques": "When should you use **recursion** vs **iteration**?",
        "answer": {
            "type": "text",
            "content": "**Recursion:**\n- Function calls itself\n- Uses call stack\n- Good for: trees, divide & conquer\n- Risk: stack overflow\n\n**Iteration:**\n- Uses loops\n- Generally more efficient\n- Good for: simple repetition\n\n**Example: Factorial**\n```\n// Recursive\nfact(n) = n * fact(n-1)\n\n// Iterative\nresult = 1\nfor i in 1 to n:\n    result *= i\n```\n\n**Tail recursion** can be optimized to iteration by compilers."
        },
        "explanation": "Any recursive solution can be converted to iterative (and vice versa). Choose based on readability and efficiency."
    },
    {
        "title": "Memory Management üíæ",
        "ques": "Explain **stack vs heap** memory and garbage collection.",
        "answer": {
            "type": "text",
            "content": "**Stack Memory:**\n- LIFO (Last In, First Out)\n- Stores local variables, function calls\n- Fast allocation\n- Limited size (stack overflow)\n- Automatically managed\n\n**Heap Memory:**\n- Stores objects, dynamic allocations\n- Slower allocation\n- Larger, flexible size\n- Must be managed (or garbage collected)\n\n**Garbage Collection:**\n- Automatically frees unused memory\n- Languages: Java, Python, C#, Go\n- Manual: C, C++ (malloc/free)"
        },
        "explanation": "Memory leaks occur when allocated memory isn't freed. Use smart pointers in C++."
    },
    {
        "title": "APIs and Interfaces üîå",
        "ques": "What is an **API** and why are interfaces important?",
        "answer": {
            "type": "text",
            "content": "**API (Application Programming Interface):**\nContract specifying how software components interact\n\n**Types:**\n| Type | Example |\n|------|--------|\n| Library API | Python's `math.sqrt()` |\n| Web API | Twitter API, REST |\n| OS API | File system calls |\n\n**Interfaces:**\n- Define what methods a class must implement\n- Allow different implementations\n- Enable loose coupling\n\n```java\ninterface Drawable {\n    void draw();\n}\n```"
        },
        "explanation": "Good APIs are stable, documented, and hide implementation details. Program to interfaces, not implementations."
    },
    {
        "title": "Version Control üìù",
        "ques": "Explain **Git** basics: commit, branch, merge, pull request.",
        "answer": {
            "type": "text",
            "content": "**Git Concepts:**\n\n| Concept | Description |\n|---------|------------|\n| **Repository** | Project folder with history |\n| **Commit** | Snapshot of changes |\n| **Branch** | Parallel development line |\n| **Merge** | Combine branches |\n| **Pull Request** | Request to merge changes |\n\n**Common Commands:**\n```bash\ngit init          # Create repo\ngit add .         # Stage changes\ngit commit -m \"\" # Save snapshot\ngit branch feat   # Create branch\ngit checkout feat # Switch branch\ngit merge feat    # Merge into current\n```"
        },
        "explanation": "Version control enables collaboration and maintains history. GitHub, GitLab are hosting services."
    }
]